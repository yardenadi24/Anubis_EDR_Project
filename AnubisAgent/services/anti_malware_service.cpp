#include "anti_malware_service.h"
#include "filesystem_utils.h"
#include "commons.h"
#include <algorithm>

AntiMalwareService::AntiMalwareService(ServiceManager* pServiceManager)
    :m_state(ServiceState::STOPPED),
    m_serviceManager(pServiceManager),
    m_logger(Logger::GetInstance()),
    m_securityEventService(static_cast<SecurityEventService*>(pServiceManager->GetService("SecurityEvent").get())),
    m_verdictDbService(static_cast<VerdictDbService*>(pServiceManager->GetService("VerdictDb").get())),
    m_isRunning(FALSE),
    m_totalScans(0),
    m_totalBlocked(0),
    m_scanTimeoutMs(10000) // Default timeout: 10 seconds
{
}

AntiMalwareService::~AntiMalwareService()
{
    Stop();
}

bool AntiMalwareService::Initialize()
{
    m_logger.Info(m_name, "Initializing anti-malware service");
    
    // Load configuration
    if (!LoadConfiguration()) {
        m_logger.Warning(m_name, "Failed to load configuration, using defaults");
    }

    // Initialize all registered modules
    {
        std::lock_guard<std::mutex> lock(m_modulesMutex);
        for (auto& module : m_modules)
        {
            std::map<std::string, std::string> moduleConfig;
            std::string modulePrefix = module->GetName() + ".";
            
            // Extract module-specific configuration
            for (const auto& pair : m_config) {
                if (pair.first.find(modulePrefix) == 0) {
                    std::string key = pair.first.substr(modulePrefix.length());
                    moduleConfig[key] = pair.second;
                }
            }

            // Configure and initialize the module
            module->Configure(moduleConfig);
            if (!module->Initialize()) {
                m_logger.Warning(m_name, "Failed to initialize module: " + module->GetName());
            }
            else {
                m_logger.Info(m_name, "Initialized module: " + module->GetName());
            }
        }

        // Sort modules by priority
        SortModulesByPriority();
    }

    m_logger.Info(m_name, "Anti-malware service initialized with " + std::to_string(m_modules.size()) + " security modules");

    m_state = ServiceState::STOPPED;
    return true;
}

bool AntiMalwareService::Start()
{
    if (m_state == ServiceState::RUNNING) {
        m_logger.Warning(m_name, "Service already running");
        return TRUE;
    }

    m_logger.Info(m_name, "Starting anti-malware service");

    // Check if we have any modules
    if (m_modules.empty()) {
        m_logger.Warning(m_name, "No security modules registered");
    }

    // Start the service
    m_state = ServiceState::STARTING;
    // Start the scan thread
    m_scanThread = std::thread(&AntiMalwareService::ScanThreadProc, this);

    m_isRunning = TRUE;
    m_state = ServiceState::RUNNING;

    m_logger.Info(m_name, "Anti-malware service started");
    return TRUE;
}

void AntiMalwareService::Stop()
{
    m_logger.Info(m_name, "Stopping anti-malware service");
    
    if (m_state != ServiceState::RUNNING) {
        m_logger.Info(m_name, "anti-malware service not running");
        return;
    }

    // Signal the scan thread to stop
    m_state = ServiceState::STOPPING;
    m_isRunning = FALSE;

    // Wake up the scan thread
    m_queueCondition.notify_all();

    // Wait for the scan thread to exit
    if (m_scanThread.joinable()) {
        m_scanThread.join();
    }

    // Shutdown all modules
    {
        std::lock_guard<std::mutex> lock(m_modulesMutex);

        for (auto& module : m_modules) {
            module->Shutdown();
            m_logger.Info(m_name, "Shutdown module: " + module->GetName());
        }
    }

    m_state = ServiceState::STOPPED;
    m_logger.Info(m_name, "Anti-malware service stopped");
}

bool AntiMalwareService::Configure(const std::map<std::string, std::string>& config)
{
    std::lock_guard<std::mutex> lock(m_configMutex);

    m_logger.Info(m_name, "Configuring anti-malware service");

    // Store configuration
    m_config = config;

    // Apply configuration
    return LoadConfiguration();
}

BOOL AntiMalwareService::RegisterModule(std::shared_ptr<ISecurityModule> module)
{
    if (!module) {
        m_logger.Error(m_name, "Cannot register null module");
        return FALSE;
    }

    std::lock_guard<std::mutex> lock(m_modulesMutex);

    const std::string& moduleName = module->GetName();
    for (const auto& existingModule : m_modules) {
        if (existingModule->GetName() == moduleName) {
            m_logger.Warning(m_name, "Module already registered: " + moduleName);
            return FALSE;
        }
    }

    // Add to modules list
    m_modules.push_back(module);

    // Extract module-specific configuration
    std::map<std::string, std::string> moduleConfig;
    std::string modulePrefix = moduleName + ".";

    for (const auto& pair : m_config) {
        if (pair.first.find(modulePrefix) == 0) {
            std::string key = pair.first.substr(modulePrefix.length());
            moduleConfig[key] = pair.second;
        }
    }

    // Configure the module
    module->Configure(moduleConfig);

    // If service is already running, initialize the module
    if (m_state == ServiceState::RUNNING) {
        if (!module->Initialize()) {
            m_logger.Warning(m_name, "Failed to initialize module: " + moduleName);
        }
    }

    // Sort modules by priority
    SortModulesByPriority();

    m_logger.Info(m_name, "Registered security module: " + moduleName);

    return TRUE;
}

BOOL AntiMalwareService::UnregisterModule(const std::string& moduleName)
{
    std::lock_guard<std::mutex> lock(m_modulesMutex);

    // Find the module
    auto it = std::find_if(m_modules.begin(), m_modules.end(),
        [&moduleName](const std::shared_ptr<ISecurityModule>& module) {
            return module->GetName() == moduleName;
        });

    if (it == m_modules.end()) {
        m_logger.Warning(m_name, "Module not found: " + moduleName);
        return FALSE;
    }

    // Shutdown the module if running
    if (m_state == ServiceState::RUNNING) {
        (*it)->Shutdown();
    }

    // Remove from modules list
    m_modules.erase(it);

    m_logger.Info(m_name, "Unregistered security module: " + moduleName);

    return TRUE;
}

size_t AntiMalwareService::GetModuleCount()
{
    std::lock_guard<std::mutex> lock(m_modulesMutex);
    return m_modules.size();
}

std::vector<std::string> AntiMalwareService::GetModulesNames()
{
    std::lock_guard<std::mutex> lock(m_modulesMutex);

    std::vector<std::string> names;
    names.reserve(m_modules.size());

    for (const auto& module : m_modules) {
        names.push_back(module->GetName());
    }

    return names;
}

BOOL AntiMalwareService::ScanFile(const std::string& filePath, VerdictCallback callback, void* context)
{
    if (m_state != ServiceState::RUNNING) {
        m_logger.Warning(m_name, "Cannot scan file - service not running");
        return FALSE;
    }

    m_logger.Info(m_name, "Submitting file for scanning: " + filePath);

    // Create scan request
    ScanRequest request;
    request.filePath = filePath;
    request.callback = callback;
    request.context = context;

    // Add to queue
    {
        std::lock_guard<std::mutex> lock(m_queueMutex);
        m_scanQueue.push(request);
    }

    // Notify scan thread
    m_queueCondition.notify_one();

    return TRUE;
}

BOOL AntiMalwareService::LoadConfiguration()
{

    // Get scan timeout
    auto it = m_config.find("ScanTimeoutMs");
    if (it != m_config.end()) {
        char* endPtr = NULL;
        DWORD timeout = strtoul(it->second.c_str(), &endPtr, 10);
        if (endPtr != it->second.c_str() && *endPtr == '\0') {
            m_scanTimeoutMs = timeout;
        }
        else {
            m_logger.Warning(m_name, "Invalid scan timeout value: " + it->second);
        }
    }

    // Create modules directory if configured
    it = m_config.find("ModulesDirectory");
    if (it != m_config.end()) {
        std::string modulesDir = it->second;
        if (!CreateDirectoryPath(modulesDir, m_name)) {
            m_logger.Warning(m_name, "Failed to create modules directory: " + modulesDir);
        }
    }

    // Create rules directory if configured
    it = m_config.find("RulesDirectory");
    if (it != m_config.end()) {
        std::string rulesDir = it->second;
        if (!CreateDirectoryPath(rulesDir, m_name)) {
            m_logger.Warning(m_name, "Failed to create rules directory: " + rulesDir);
        }
    }

    m_logger.Info(m_name, "Configuration loaded: ScanTimeoutMs=" + std::to_string(m_scanTimeoutMs));

    return TRUE;
}

void AntiMalwareService::ScanThreadProc() {
    m_logger.Info(m_name, "Scan thread started");

    while (m_isRunning) {

        ScanRequest request;
        BOOL hasRequest = FALSE;

        {
            std::unique_lock<std::mutex> lock(m_queueMutex);

            // Wait for scan request or stop signal
            m_queueCondition.wait(lock, [this]() {
                return !m_isRunning || !m_scanQueue.empty();
                });

            // Check for shutdown
            if (!m_isRunning && m_scanQueue.empty()) {
                break;
            }

            // Get the next request
            if (!m_scanQueue.empty()) {
                request = m_scanQueue.front();
                m_scanQueue.pop();
                hasRequest = TRUE;
            }
        }

        // Process the request
        if (hasRequest) {
            m_logger.Info(m_name, "Processing scan request: " + request.filePath);

            // Process the scan
            ProcessScanRequest(request);
        }
    }

    m_logger.Info(m_name, "Scan thread exited");
}

BOOL AntiMalwareService::ProcessScanRequest(const ScanRequest& request)
{
    // Increment scan counter
    m_totalScans++;

    // Check if file exists
    HANDLE hFile = CreateFileA(
        request.filePath.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD error = GetLastError();
        m_logger.Error(m_name, "File access error: " + request.filePath +
            ", Error: " + std::to_string(error));

        // Call callback with allow verdict (can't scan)
        if (request.callback) {
            request.callback(TRUE, request.context);
        }

        return FALSE;
    }

    // Close the file handle
    CloseHandle(hFile);

    // Create analysis result
    AnalysisResult finalResult;
    finalResult.shouldBlock = FALSE;

    // Copy modules to a local vector to avoid holding the lock during scanning
    std::vector<std::shared_ptr<ISecurityModule>> modules;
    {
        std::lock_guard<std::mutex> lock(m_modulesMutex);
        modules = m_modules;
    }

    // Check if we have any modules
    if (modules.empty()) {
        m_logger.Warning(m_name, "No security modules available for scanning");

        // Call callback with allow verdict (no modules)
        if (request.callback) {
            request.callback(TRUE, request.context);
        }

        return TRUE;
    }

    // Process each module until we get a block verdict
    for (auto& module : modules)
    {

        // Skip if module is not initialized
        if (!module)
        {
            continue;
        }

        // Create result for this module
        AnalysisResult moduleResult;
        moduleResult.shouldBlock = FALSE;

        // Analyze the file with this module
        m_logger.Info(m_name, "Analyzing file with module: " + module->GetName());

        if (module->AnalyzeFile(request.filePath, moduleResult))
        {
            if (moduleResult.shouldBlock)
            {
                // We found a reason to block, use this result
                finalResult = moduleResult;

                m_logger.Warning(m_name, "Module " + module->GetName() +
                    " voted to block file: " + request.filePath +
                    ", Reason: " + moduleResult.reason);

                // Stop processing further modules
                break;
            }
            else {
                m_logger.Info(m_name, "Module " + module->GetName() +
                    " voted to allow file: " + request.filePath);
            }
        }
        else {
            m_logger.Warning(m_name, "Module " + module->GetName() +
                " failed to analyze file: " + request.filePath);
        }
    }

    // Update blocked counter if needed
    if (finalResult.shouldBlock) {

        // In AntiMalwareService.cpp's ProcessScanRequest method, replace:
        std::string fileHash = m_verdictDbService->CalculateFileHash(request.filePath);

        if (!fileHash.empty())
        {
            m_logger.Info(m_name, "Adding malicious file hash to database: " + fileHash);

            // Create hash entry
            HashEntry entry;
            entry.hash = fileHash;
            entry.verdict = HashVerdict::BLOCK;
            entry.description = "Auto-added: " + finalResult.reason;
            entry.isLocal = true;

            // Add to database
            if (m_verdictDbService->AddHashEntry(entry)) {
                m_logger.Info(m_name, "Successfully added malicious hash to database");
            }
            else {
                m_logger.Warning(m_name, "Failed to add malicious hash to database");
            }

        }
        else {
            m_logger.Warning(m_name, "Failed to calculate hash for malicious file");
        }

        m_totalBlocked++;

        // Create event metadata
        std::map<std::string, std::string> metadata;
        metadata["detection_module"] = finalResult.moduleName;
        metadata["block_reason"] = finalResult.reason;

        for (size_t i = 0; i < finalResult.detections.size(); i++) {
            metadata["detection_" + std::to_string(i + 1)] = finalResult.detections[i];
        }

        m_securityEventService->CreateEvent(
            "AntiMalware",                      // Source
            "MALWARE_DETECTED",                 // Type
            "Malicious file detected",          // Description
            finalResult.reason,                 // Details
            request.filePath,                   // File path
            SecurityEventSeverity::HIGH,        // Severity
            metadata,                           // Additional metadata
            true                                // Show alert
        );

        m_logger.Info(m_name, "TODO::Security event created for malware detection: " + request.filePath);
    }

    // Call the callback with the final verdict
    if (request.callback)
    {
        // For shouldBlock=TRUE, we return FALSE (block)
        // For shouldBlock=FALSE, we return TRUE (allow)
        BOOL verdict = !finalResult.shouldBlock;

        m_logger.Info(m_name, "Final verdict for file: " + request.filePath + " is " + (verdict ? "ALLOW" : "BLOCK"));

        request.callback(verdict, request.context);
    }

    return TRUE;
}

void AntiMalwareService::SortModulesByPriority()
{
    std::sort(m_modules.begin(), m_modules.end(),
        [](const std::shared_ptr<ISecurityModule>& a, const std::shared_ptr<ISecurityModule>& b) {
            return a->GetPriority() < b->GetPriority();
        });
}